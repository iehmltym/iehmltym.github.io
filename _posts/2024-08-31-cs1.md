---
layout:     post
title:      "[日本IT技術]1：プレゼンテーション"
subtitle:   "技術ほうれん草"
date:       2024-08-31 12:00:00
author:     "iehmltym（張）"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - IT業界
    - キャリア開発
    - 技術スタック
    - プレゼンテーション
    - プレ
---

> "Yeah It's on. "



## ☀️🗣️プレゼンテーション・プレゼン[一]：テスト_測試-命令網羅-判定条件/分岐網羅-条件網羅-複数条件網羅
 
皆さま、本日はソフトウェアテストの重要な手法についてお話しします。特に、命令網羅と判定条件網羅という2つの手法に焦点を当てます。

まず、命令網羅についてご説明します。命令網羅とは、プログラム内のすべての命令を少なくとも1回は実行する方法です。フローチャートで考えると、すべての処理ボックスを通過するテストを行うことになります。
例えば、スライドに示すフローチャートをご覧ください。ここでは、Xイコール1かつYイコール3という条件があります。条件がYESの場合は処理1と処理2を、NOの場合は処理2のみを実行します。
命令網羅を達成するには、条件がYESとなるケースを1回テストするだけで十分です。これにより、すべての処理ボックスを通過できます。つまり、最小テスト回数イコール1回となります。

次に、判定条件網羅、別名分岐網羅についてお話しします。この手法は、フローチャート内のすべての分岐を少なくとも1回は通過することを目的としています。
先ほどのフローチャートを例に取ると、YESの場合とNOの場合の両方をテストする必要があります。なぜなら、YESの場合は横の線を、NOの場合は縦の線を通らないからです。
したがって、判定条件網羅を満たすには、条件がYESの場合とNOの場合の2回テストが必要です。つまり、最小テスト回数イコール2回となります。

「次に、条件網羅について説明します。条件網羅とは、各条件式のYes、Noの組み合わせを少なくとも一度は確認する手法です。これまでの手法と異なり、条件網羅では分岐の中の個々の条件式に着目します。
今回の例では、Xイコール1という条件1と、Yイコール3という条件2に注目します。これらの条件のYes、Noの組み合わせは4通りあります。条件網羅を満たすには、条件1と2がそれぞれYes、Noとなるケースをチェックすれば十分です。
例えば、パターン1とパターン4をテストすると、両方の条件式でYesとNoの組み合わせを確認できます。重要なのは、個別の条件式のYesとNoを満たすことであり、条件式全体の結果は関係ありません。

最後に、複数条件網羅について説明します。これは各条件式のYes、Noの組み合わせをすべて確認する手法です。つまり、条件式1と2のYes、Noのすべての組み合わせ、パターン1から4までのすべてのテストケースを実施する必要があります。
このように、網羅のパターンによってチェックする観点や厳密さが変わってきます。それぞれの手法の特徴をよく理解し、適切に使い分けることが重要です。
これらの手法を適切に使用することで、より効果的なソフトウェアテストが可能になります。ご清聴ありがとうございました。」

以上で単体テストにおけるホワイトボックステストの説明を終わります。次に結合テストについて見ていきます。」
 
## ☀️🗣️プレゼンテーション・プレゼン[二]：画面_ボタン_画面操作_情報登録_情報検索_帳票出力＿エラー対応＿設定の変更

画面操作説明を含む3つのシナリオをご紹介します：
 
### 新機能のデモンストレーション：
 
「本日は、新しく実装した顧客管理システムの操作方法をご説明いたします。 まず、画面左上の「顧客追加」ボタンをクリックします。表示されるフォームに、顧客の基本情報を入力します。入力完了後、「保存」ボタンを押すと、データベースに情報が登録されます。 次に、顧客情報の検索方法をお示しします。画面上部の検索バーに、顧客名や企業名を入力し、虫眼鏡アイコンをクリックすると、該当する顧客情報が表示されます。 最後に、レポート機能についてご説明します。画面右上の「レポート」タブをクリックすると、各種分析レポートを生成できます。期間や顧客セグメントを選択し、「生成」ボタンを押すと、グラフや表が自動で作成されます。 これらの機能により、顧客データの管理と分析が効率化されます。操作方法について、ご質問はございますか？」
 
### エラー対応手順の説明：
 
「システムエラーが発生した際の対応手順をご説明いたします。 まず、エラーメッセージが表示されたら、画面右下の「エラー詳細」ボタンをクリックします。表示される情報をスクリーンショットで保存してください。 次に、画面上部の「ヘルプ」メニューから「トラブルシューティング」を選択します。ここに表示される一般的な解決策をお試しください。 それでも解決しない場合は、「サポート依頼」ボタンをクリックし、表示されるフォームにエラーの詳細と再現手順を記入してください。添付ファイル欄に先ほど保存したスクリーンショットを添付し、送信してください。 これらの手順を踏むことで、迅速かつ正確な問題解決が可能となります。ご不明な点はございますか？」
 
### セキュリティ設定の変更手順：
 
「本日は、セキュリティ強化のための設定変更手順をご案内いたします。 はじめに、画面右上のユーザーアイコンをクリックし、「設定」を選択します。表示される画面で「セキュリティ」タブを開きます。 ここで、「パスワード変更」ボタンをクリックし、新しいパスワードを設定します。パスワードは最低12文字以上で、大文字、小文字、数字、特殊文字を含める必要があります。 次に、「二段階認証」の項目を有効にします。表示される QR コードをスマートフォンの認証アプリでスキャンし、生成されたコードを入力して設定を完了します。 最後に、「ログイン履歴」セクションで、不審なアクセスがないか確認します。不審な活動が見られた場合は、すぐに「アカウントロック」ボタンを押してください。 これらの設定により、アカウントのセキュリティが大幅に向上します。操作方法について、ご不明な点はありますか？」

これらの説明は、視覚的な要素（ボタンの位置、画面の構成）と具体的な操作手順を組み合わせており、ユーザーが容易に理解し、実行できるように構成されています。また、各説明の最後に質問の機会を設けることで、理解度の確認と追加の説明の機会を提供しています。
 
 
## ☀️🗣️プレゼンテーション・プレゼン[三]　：プログラムを宣言＿関数かんすう_引数ひきすう_変数へんすう配列＿呼び出す
 
それでは上から順番に文法を見ていきましょう。
まず、白丸手続き名もしくは関数名と書くことでプログラムの作成を宣言します。手続きや関数はプログラムと似たものです。厳密には異なりますが、試験ではその違いはあまり気にしなくて大丈夫です。
プログラムを作る際は最初に宣言処理を行い、コンピューターに「こんなプログラムを作るよ」と教えてあげる必要があります。また、宣言時に括弧で引数を指定できます。引数とはプログラムに入力するデータのことです。
最初に確認した通り、プログラムは入力されたデータに対し何かしらの処理を行って、その結果を出力するものでした。この時の入力データを引数として定義します。
プログラムには複数の引数を指定することも可能で、その際は指定した順に第1引数、第2引数と呼んでいきます。大抵のプログラムには引数が定義されていますが、稀に引数がないプログラムもあります。それではプログラムの宣言について実際のサンプル問題を確認してみましょう。
白丸appendかこ文字型キバと宣言されています。

○Append(文字型:キュー)

これは、Appendというプログラムの作成を宣言しています。引数として「文字型:キュー」と記載されているのは、引数として文字型の変数「キュー」を宣言する処理です。つまり、プログラムAppendは文字型変数「キュー」を入力データとして何らかの処理を行うものだとわかります。
 
なお、このプログラム名は処理のヒントになることがあります。例えば、appendは日本語で「追加する」という意味なので、このプログラムは何かしらのデータをどこかに追加する処理なんだなと予想することができます。

また、問題によっては手続きが宣言されないケースもあります。例えば今画面に見せた問題ではプログラム名の宣言が行われていません。プログラム名の宣言をしなくてもプログラム自体作ることは可能ですが、プログラムの名前をつけておくと作ったプログラムを別のプログラムで呼び出して使うことができるので便利です。

---------

次に変数と配列の宣言を行います。変数と配列を使用する際は必ず宣言することが必要です。宣言する場合は「変数もしくは配列の方コロン    変数名もしくは配列名」と指定します。変数や配列には整数型や論理型などデータ型があることは前の章で確認しましたね。変数や配列の宣言時にこの型を一緒に宣言します。
サンプル問題を見ていきましょう。最初に「整数型の配列コロンarray（アレ）」と宣言されているので、このように整数型の配列が生成されます。また「整数型コロンright（ライト）left（レフト）tmp（テプ）」で変数が生成されます。試験では配列を宣言する時は「整数型の配列」と記載し、変数を宣言する時は「整数型」としか記載されないので、その違いで配列・変数どちらを宣言しているのか把握します。

また，先ほど確認した通り、プログラムの宣言時に引数として変数や配列が宣言されることもあるので覚えておきましょう。変数や配列の名前もプログラムの名前と同様に処理のヒントになります。例えば「テプ」は「テンポラリー」、つまり「一時的」という意味の英語を省略したもので、一時的にデータを格納しておく入れ物とイメージすることができます。

またarrayアレーには矢印で1、2、3、4、5と記載されています。これはarrayという配列にデータを代入する処理です。代入とは先ほど軽く説明しましたが、変数や配列の箱の中にデータを入れ込むことです。よって配列の宣言と同時に配列arrayアレーには1、2、3、4、5という値が入ります。このように変数や配列を宣言すると同時にデータを格納することもできます。この時のデータを初期値と呼びます。
配列や変数を宣言するタイミングで初期値を入力しても良いですし、変数ライトレフトテプのように初期値を入れず空っぽの状態で変数を宣言することもOKです。

また配列の記載方法についてもここで確認しましょう。擬似言語では配列は丸括弧で定義されますので、例えば丸括弧(1、1、1)は1が3つ並んだ要素数3の1次元配列を意味します。
また2次元配列の場合、1つの丸括弧が1行を示すので、丸括弧の中にさらに丸括弧で(1、2、3)(4、5、6)(7、8、9)という配列があった場合、これは1つの括弧が1行を示す3行3列の2次元配列となります。

次に注釈です。擬似言語内で米印（※こめじるし）やスラッシュ（/）で囲まれた日本語はプログラムの注釈、つまり注意点を示しています。プログラムそのものとは関係なく、単純にコードの補足情報として記載されます。処理の補足説明になっていることもあり、テストでは重要なヒントになるのでしっかりと活用していきましょう。

次に値の代入です。これは最初に説明した順次処理の1つです。先ほどから登場している通り、「変数名もしくは配列名矢印式の値」で変数や配列にデータを入れ込むことができます。「式の値」と書いてある部分は何かしらのデータと読み替えてOKです。例えばこのサンプル問題では整数型の変数retという箱に100という値を入れ込んでいます。
 
続いてプログラムの呼び出しです。これも順次処理の1つです。「手続き名(引数)」と書くことでそのプログラムを呼び出すことができます。先ほどプログラムに名前をつけると別のプログラムで呼び出せると言いましたが、このように名前のあるプログラムは別のプログラムの中で呼び出し、その処理を実行させることができます。

例えば今画面に見せているプログラムとは別に「ソート」というプログラムが別でどこかで定義されていたとしましょう。そして画面のプログラムの中で「ソート(かこ)」と記載されています。これは別で作られたソートプログラムが呼び出されるということです。プログラムの呼び出しを行うと別途作ったソートプログラムが起動します。sortソートプログラムには引数として「firstファスト」「i-1」（マイナス）という2つが指定されていますので、ソートプログラムはこの2つの入力データを元に何かしらの処理を行って結果を出力します。
 
## ☀️🗣️プレゼンテーション・プレゼン[四]　：プログラムをIF else＿while＿do_for

ここからは分岐処理です。if文とは、条件式に応じて実施する処理を制御する構文のことで、ifからendifまでの一連の塊りのことを指します。ifからendifの間でif及びelse ifを用いて複数の条件が記載されています。この条件を上からチェックして、最初に満たした条件に対応する処理を行っていきます。

注意点として、if文では1度処理を行ったら残りのif文は実行されず、if文から抜け出します。また、どの条件にも当てはまらなかった場合は、elseの下に記載されている処理を実行してif文から抜け出します。

具体的に見ていきましょう。このコードでは変数scoreスコアとgradeグレードを用意し、スコアに代入された点数に応じて成績がグレードに格納されるという処理を示しています。ここでスコアが75点の時を考えます。if文では条件式を上から順にチェックしていきます。最初の条件はスコアが80以上という条件ですが、スコアが75なのでこの条件は満たさずfalseとなります。その場合は次の条件に移ります。次の条件ではスコアが70以上80未満となっており、この条件は満たすので、この条件式がtrueとなり、ここの下の処理に移ります。

この下の処理では変数グレードに「良し」を代入しています。そして条件にヒットしたら残っているif文の処理は行わずにif文から抜け出します。if文はifからendifまでの一塊と説明しましたので、if文から抜けるということはendifの次の処理に移るということです。

次の処理では「return gradeリターングレード」とあります。returnリターンは戻り値を返す命令です。戻り値はプログラムから出てくるもの程度の認識で大丈夫です。リターン処理ではプログラムを終了させ、処理結果を表示してくれます。よってこのプログラムを行うことでグレードに格納されている「よし」が出てくるとイメージしてください。プログラムはこのようにリターン処理を行うか、もしくは全てのプログラムの処理を完了した場合にプログラムが終了します。

さて、このif文について補足します。まず、このelse ifはif文の中に何個記載してもOKです。else ifを増やすほどその条件分岐を増やすことができます。逆にelse ifを省略することも可能です。その場合、分岐は最初のifの後ろに書かれた条件のみとなります。さらにelse以降も省略することが可能です。elseを省略すると全ての条件に当てはまらなかった場合は何も処理を発生せず次の処理に移ります。

つまり、if文で最も短い条件は画面の1番右のコードです。if条件式があり処理が記載され、そしてendifが書いてあります。この場合、if文の条件を満たした場合はその下の処理を実行しますし、条件を満たさなかった場合は何も処理を実行せずに次に移っていきます。

次にwhile文とdo文の説明です。ここからは繰り返し処理の文法に入ります。while文とdo文は共に条件がtrueの間を繰り返すことです。実際のコードを確認していきましょう。while文はwhileからendwhileまでの一塊りをさします。そしてwhile文の後ろに条件が記載されており、この条件式がtrueである限りその中の処理を繰り返します。

if文と同様に、do文も条件がtrueの時に処理を行うと覚えてください。またここでloopループ処理では無限ループとなるコードが記載できないということに注意しましょう。例えば変数countカウントに5が入っており、countカウントが0より大きいという条件でwhile文の繰り返し処理を考えます。このコードではwhile文の中の処理ではカウントに対して操作を行っていませんので、while文を何回繰り返してもカウントの値は変わらず5です。つまりwhile文のカウントが0より大きいという条件は永遠にtrueとなってしまい、while文の処理が無限ループに入ってしまいます。

これを防ぐため、例えば処理の中にcountカウントの値を1減らすといったコードが必要です。このようにwhile文の繰り返し処理では条件式に影響を与える処理が必ず必要となります。プログラムの穴埋め問題で役立つテクニックなので理解しておきましょう。

また試験にはあまり出題されませんが、do文もwhile文と同様の考え方です。do文ではdoからwhileまでの一塊りをさします。最初に処理を実行し、その後while文の条件がtrueの場合に処理を繰り返します。while文は最初に条件が来ていましたが、do文では最初に処理を行ってから条件のチェックに入ります。

最後にfor文です。for文も繰り返し処理を行う文法です。for文はforからendforまでの一塊をさしており、for文の中に記載された制御内容をもとに処理を繰り返していきます。例えばサンプルでは制御内容が「iを2からinの要素数まで1ずつ増やす」と記載されています。宣言処理よりinは整数型配列のことです。

つまり最初にi=2としてfor文の中の繰り返し処理を実施します。そして次にiの値を1増やし、i=3として、for文の中の処理を繰り返します。このようにiの値を増やしながら処理を行っていき、最終的にiの値が配列inの要素数と同じになるまでこの処理を繰り返していきます。

なお、while文とfor文はどちらも繰り返し処理を行うコードであり、それぞれのコードを置き換えることも可能です。例えばwhile文で書かれた文法はfor文を使って書き直すことができますし、その逆もしかりです。ただし、プログラムの状況によってwhile文、for文に向き不向きがあり、どちらか一方を使った方が効率的にコードを書くことができますので、while文とfor文という2つの文法が存在しています。

## ☀️🗣️プレゼンテーション・プレゼン[五]　クラス型_クラス型変数＿インスタンス生成_メンバ変数＿メソッド

飲食店のメニューを作るために、この設計書メニュークラスを用いてインスタンスを作成し、そこから各メニューを作っていきます。この時の手順として、まずはクラス型と呼ばれる変数を定義した後、作成されたインスタンスのメモリアドレスをクラス型変数に格納します。

このクラス型について最初に説明します。基本アルゴリズムで確認した通り、変数には型があり、変数宣言時にこの型も指定するのでした。例えば、整数型の変数Iを宣言する際は「整数型:I」と定義します。ですが、クラス型変数カレーメニューを定義する際の宣言方法は特殊で、「メニュー:カレメニュー」といった形で宣言します。このように、クラス型変数は「クラス名:変数名」と指定するので、慣れないうちは分かりにくいです。また、クラス名は問題によって異なるので、宣言時の記載も問題ごとに固有のクラス名となります。

ついでに、変数の名前については作成されるインスタンス名に関連することが多いです。今回はカレーのメニューを作成するためにインスタンスを作ったので、変数名をカレーメニューとしています。

さて、このクラス型変数に格納される値は少し特殊です。例えば、整数型変数では変数に整数が格納されますし、論理型だったら論理値trueかfalseが格納されました。それでは、クラス型変数には何が格納されるのでしょうか。

答えは、生成されたインスタンスのメモリアドレスです。メモリとは、基本アルゴリズムで説明した通り、コンピューターの中でデータを記憶しておく領域のことで、メモリアドレスが割り振られているのでした。生成されたインスタンスはこのメモリのどこかに存在し、そのメモリアドレスがクラス型変数に格納されます。この後また具体的に説明するので、今はなんとなく理解できればOKです。

それでは、実際にインスタンスを作成する流れを見ていきましょう。まずはクラスからインスタンスを作成します。その際は最初に「Menu:currymenu」と書いて、クラス型変数カレメニューを宣言します。次に、このカレメニューに「メニュー()」を代入するというコードを書きます。「クラス名()」という命令例はインスタンスの生成を指示するコードです。つまり、「メニュー()」を実行すると、このようなインスタンスが生成され、それが変数カレメニューに格納されます。

ただし、これだけではインスタンスが生成されただけで中身のメンバ変数はまだ空っぽです。そのため、ここにデータを入れ込みます。その際は、「carrymenu.name」に「カレー」を、「carrymenu.price」に800を代入するという処理を書きます。こうすると、メンバ変数nameに「カレー」、priceに800というデータが入ります。

シンプルなこの4行にオブジェクト指向の本質が詰まっていますので、1行ずつこの挙動をチェックしていきましょう。まず1行目では、先ほど確認したようにクラス型変数currymenuを定義しています。この処理で変数currymenuが作成されます。2行目の処理でインスタンスが生成され、クラス型メニューに代入されています。

これだけ見ると、このように変数carrymenuに直接インスタンスが格納されているように見えますが、これは誤りです。

先ほど説明した通り、クラス型変数にはインスタンスのメモリアドレスが格納されます。インスタンスが生成されると、メモリのどこかにこのようにインスタンスが出現します。クラス型変数には、このインスタンスが生成されたメモリの番号が格納されています。つまり、データそのものではなく、データの場所の情報が格納されているということです。

そして次の処理を見ていきます。「carry menu.name」と記載されています。このドットは演算子の一種で、「クラス型変数.メンバ変数」もしくは「クラス型変数.メソッドmethod」という形で使います。この命令によって、変数内のメモリアドレスに格納されているインスタンスのメンバ変数もしくはメソッドへアクセスすることができます。これを、メンバ変数もしくはメソッドの参照と呼びます。

つまり、現在のcarrymenuクラスに格納されている748のメモリアドレスに格納されているインスタンスのメンバー変数nameにアクセスしています。ここに「カレー」を代入しているので、インスタンスの中のnameに「カレー」が入るということです。

よくある間違いとしては、インスタンスの名前がcarrymenuだと勘違いしてしまい、「carrymenu.name」というのは直接インスタンス内のメンバ変数にアクセスすると間違ってしまう人が多いです。

しかし、これは誤った考え方で、あくまで変数carrymenuにあるメモリアドレスを経由してインスタンスにアクセスします。

例えば、変数カレメニューの中に222番が格納されている場合は222番のメモリにアクセスしてしまい、処理がエラーとなります。この考え方は最初は違和感があると思いますが、大切な考え方なので必ず理解してください。

このようにして、インスタンスの中のnameに「カレー」を代入します。priceも全く同様の考え方でインスタンスの中に800が代入されます。こうして、メニューの1つを作成することができました。

この調子で他のメニューを作成していきましょう。サラダやグラタンのメニューを作るために、まずはクラス型変数saladmenuやgratinmenuを作成します。そして、クラス型変数を定義した後、クラスからインスタンスを作成します。そして、各インスタンスのメンバ変数に参照し、メニューの名前と価格を入れていきます。

ですが、ここでいちいちインスタンスを作成した後にメニュー情報と価格を入れていくのはかなりめんどくさいです。そこで最後に、メニュー情報と価格も自動でインスタンスに入力させる方法を学習していきます。その方法は、クラスを定義したコードの中にコンストラクタ(构造函数)と呼ばれるメソッドを追加し、メンバ変数に引数を自動入力するようコードを書くことです。　

コンストラクターをクラスに追加する際もクラス内にプログラムを書く必要がありますが、その記述も試験では問われないので具体的な記載方法は省略します。

さて、このコンストラクタは何かと言うと、メソッドの特別版と思ってください。コンストラクタはメソッドと同様に何かしらの処理を行うプログラムですが、コンストラクタで定義された処理はインスタンスが生成する際に自動で実行されます。また、基本的に1つのクラスにつき基本は1つのコンストラクタが定義され、コンストラクタとクラスの名称は同じものになります。イメージとしては、クラス内にコンストラクタを記載すると、元々あったクラスのメソッドに加え、このように特別なメソッドであるコンストラクタメニューが追加されると思ってください。

ではこのメソッドsumとコンストラクタメニューの違いを簡単に比較してみましょう。まず名称について、メソッドの名前はクラス内でプログラムを書くことで自由に設定できますが、コンストラクタの名前はクラス名と同じものになります。処理の内容自体は、メソッドもコンストラクタもクラス内にプログラムを書くことで自由に設定できます。

そして、処理が発生するタイミングが最も大切な違いです。メソッドはインスタンスが生成された後、プログラムでそのメソッドを呼び出すことで処理を実行します。一方、コンストラクタはインスタンスが生成されるタイミングで自動で処理が起動します。

例えば、下のプログラムは2行目でインスタンスを生成して変数currymenuに代入しています。もしクラスの中にコンストラクタが定義されている場合、このインスタンス生成タイミングでコンストラクタの処理が自動で起動されます。メソッドを使いたい場合は、その後に「クラス型変数.METHOD名」と記載することでインスタンス内のメソッドを参照させて起動させる必要があります。

まとめると、クラスはデータを表すメンバ変数、処理を表すメソッド、メソッドの特別版であるコンストラクタの3つで構成されています。全ての要素を定義しているケースもいずれかしか使わないケースもあります。それぞれの内容は、試験では表でまとめて説明されます。

また、メンバ変数はクラスの中にあるという以外は通常の変数と変わらないので、メンバ変数にも変数の型が存在しており、それも表で定義されています。同様に、メソッドやコンストラクタもクラス内にあるということ以外は通常のプログラムと変わらないので、何かを入力する、処理を行う、何かが出てくるという3点セットは変わりません。通常のプログラムと同様に、入力値や出力値がないなどの例外もあります。

この入力値、処理、出力値も表で定義されており、引数が入力値、戻り値が出力値、説明に記載されていることが処理内容と思ってOKです。

そして、クラスを活用するためにインスタンスを作成します。コンストラクタはインスタンス作成時の処理で役割が終わるので、インスタンスはコンストラクタを保持しません。この関係性をしっかりと理解しておきましょう。

それでは、メニュー作成に戻ってコンストラクタの有用性を見ていきます。クラス内でコンストラクタを定義します。コンストラクタの処理内容は、インスタンス生成時に第1引数をメンバ変数nameに、第2引数をメンバ変数priceに格納するという処理だとしましょう。

そして、menu()メニュー括弧でインスタンスを作成し変数カcarrymenuレに代入します。先ほどmenu()メニュー括弧の中は空でしたが、今回は「カレー、800」というデータを入れています。このように、インスタンスを作成する際は括弧内に引数としてデータを定義することもできます。

そして、インスタンスの作成タイミングでコンストラクタが自動で起動し、第1引数つまり最初の引数「カレー」をメンバ変数nameに、第2引数800をメンバ変数priceに格納します。こうすることで、引数を指定してインスタンスを作るだけでcarrymenuを勝手に作ることができます。

他のメニューも同様です。コンストラクタがない場合はインスタンスを作ってからいちいち名前と価格を代入していましたが、一度クラス内にコンストラクターを用意してしまえば、インスタンスを作成するだけでメニューが勝手に作成されます。

それでは最後に、オブジェクト指向の重要な点を復習していきます。

クラスとは共通事項をまとめた設計書のことで、メンバ変数、メソッド、コンストラクタで構成されます。これらの説明については、試験では日本語で記載されています。

クラス型変数とは、インスタンスが格納されているメモリアドレスを格納する変数のことで、「クラス名:変数名」で宣言します。

インスタンスとは、クラスから作成された具体的な実態で、メンバ変数とメソッドから構成されています。コンストラクタはインスタンス生成時の処理で役割が終わるので、インスタンスはコンストラクタを保持しません。

インスタンスを生成する際は、クラス型変数に「クラス名()」を代入します。このコードにより、クラス型変数にインスタンスのメモリアドレスが格納されます。

インスタンス生成時は、クラス名括弧の中に複数引数を入れることも、逆に引数を入れないことも可能です。

クラスでコンストラクタが定義されている場合は、インスタンス生成と同時にコンストラクタが起動します。

インスタンス内のメンバ変数やメソッドの参照は、「クラス型変数.メンバ変数」もしくは「クラス型変数.METHOD」と記載することでアクセスできます。



![img](/img/20240831/image001.png)
![img](/img/20240831/image002.png)
![img](/img/20240831/image003.png)
![img](/img/20240831/image004.png)
![img](/img/20240831/image005.png)
![img](/img/20240831/image006.png)
![img](/img/20240831/image007.png)
![img](/img/20240831/image008.png)
![img](/img/20240831/image009.png)
![img](/img/20240831/image010.png)
![img](/img/20240831/image011.png)
![img](/img/20240831/image012.png)
![img](/img/20240831/image013.png)
![img](/img/20240831/image014.png)
![img](/img/20240831/image015.png)
![img](/img/20240831/image016.png)
![img](/img/20240831/image017.png)
![img](/img/20240831/image018.png)
![img](/img/20240831/image019.png)
![img](/img/20240831/image020.png)
![img](/img/20240831/image021.png)
![img](/img/20240831/image022.png)
![img](/img/20240831/image023.png)
![img](/img/20240831/image024.png)
![img](/img/20240831/image025.png)
![img](/img/20240831/image026.png)
![img](/img/20240831/image027.png)
![img](/img/20240831/image028.png)
![img](/img/20240831/image029.png)
![img](/img/20240831/image030.png)
![img](/img/20240831/image031.png)
![img](/img/20240831/image032.png)
![img](/img/20240831/image033.png)
![img](/img/20240831/image034.png)
![img](/img/20240831/image035.png)
![img](/img/20240831/image036.png)
![img](/img/20240831/image037.png)
![img](/img/20240831/image038.png)
![img](/img/20240831/image039.png)
![img](/img/20240831/image040.png)
![img](/img/20240831/image041.png)
![img](/img/20240831/image042.png)



